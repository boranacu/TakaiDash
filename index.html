<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TAKAI Dash</title>
<style>
  :root { --bg:#0e0f13; --fg:#f6f7fb; --muted:#9aa3b2; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #wrap{max-width:960px;margin:0 auto;padding:12px}
  #hud{display:flex;justify-content:space-between;align-items:center;margin:6px 0 10px}
  #hud .title{font-weight:700;letter-spacing:.3px}
  #hud .score{font-variant-numeric:tabular-nums}
  canvas{width:100%;height:auto;border-radius:12px;background:#1b1d24;box-shadow:0 8px 30px rgba(0,0,0,.35)}
  .hint{margin-top:8px;color:var(--muted);font-size:.92rem}
  .btn{appearance:none;background:#2a2e39;color:#fff;border:none;border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
</style>
</head>
<body>
<div id="wrap">
  <div id="hud">
    <div class="title">üö¥‚Äç‚ôÇÔ∏è TAKAI Dash</div>
    <div>
      <span class="score">Score: <b id="score">0</b></span>
      &nbsp;|&nbsp;
      <span class="score">Best: <b id="best">0</b></span>
      &nbsp;&nbsp;<button id="reset" class="btn" title="Reset best score">Reset</button>
    </div>
  </div>
  <canvas id="game" width="960" height="540"></canvas>
  <div class="hint">Controls: <b>Space / ‚Üë / Tap</b> to jump. Avoid üöß cones, collect üü° coins.</div>
</div>

<script>
(() => {
  // ===== Canvas bootstrapping (handles HiDPI) =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  function fixDPR() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.round(rect.width  * dpr);
    canvas.height = Math.round(rect.width * (540/960) * dpr); // keep 16:9
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fixDPR(); addEventListener('resize', fixDPR);

  // ===== Game constants =====
  const GROUND_Y = 420;              // ground baseline (px)
  const GRAVITY  = 0.85;             // fall accel
  const JUMP_VY  = -16.5;            // jump impulse
  const BASE_SPEED = 1;              // world scroll speed
  const COIN_GAIN = 10;              // score per coin
  const LANE_DASH_W = 36;

  // ===== Assets =====
  const bikeImg = new Image();
  bikeImg.src = 'assets/bike.png'; // put your PNG here
  let bikeReady = false;
  bikeImg.onload = () => { bikeReady = true; };

  const bikeJumpImg = new Image();
  bikeJumpImg.src = 'assets/bike_jump.png';
  let bikeJumpReady = false;
  bikeJumpImg.onload = () => { bikeJumpReady = true; };
  
  const coneImg = new Image();
  coneImg.src = 'assets/cone.png';
  let coneReady = false;
  coneImg.onload = () => { coneReady = true; };

  // ===== State =====
  const state = { phase:'ready', time:0, score:0, best: +(localStorage.getItem('bike_best')||0) };
  document.getElementById('best').textContent = state.best;

  const player = {
    x: 110,
    y: GROUND_Y - 120,
    w: 140, h: 120,
    vy: 0,
    onGround:true,
    hitbox(){ // slightly smaller than sprite
      return { x:this.x+18, y:this.y+20, w:this.w-36, h:this.h-28 };
    }
  };

  const obstacles = []; // bombs
  const coins = [];
  let spawnBombTimer = 0;
  let spawnCoinTimer = 0;

  // ===== Input =====
  let pressed = false;
  function jump() {
    if (player.onGround && state.phase==='playing'){
      player.vy = JUMP_VY;
      player.onGround = false;
    } else if (state.phase==='ready'){
      startGame();
    } else if (state.phase==='gameover'){
      startGame(true);
    }
  }
  addEventListener('keydown', (e) => {
    if (e.code==='Space' || e.code==='ArrowUp') { e.preventDefault(); jump(); }
    if (e.code==='KeyR' && state.phase==='gameover') startGame(true);
  });
  canvas.addEventListener('pointerdown', jump);

  document.getElementById('reset').onclick = () => {
    localStorage.removeItem('bike_best');
    state.best = 0; document.getElementById('best').textContent = 0;
  };

  // ===== Helpers =====
  function aabb(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }
  function rand(min,max){ return Math.random()*(max-min)+min; }

  function startGame(reset=false){
    state.phase = 'playing';
    if (reset) { obstacles.length = 0; coins.length = 0; state.score = 0; state.time = 0; }
  }

  // ===== Spawn logic =====
  function spawnCone() {
  const size = rand(44, 58);
  obstacles.push({
    x: canvas.width / (ctx.getTransform().a) + rand(0,40),
    y: GROUND_Y - size,
    w: size,
    h: size,
    type: 'cone'
  });
}
  function spawnCoin() {
    const size = 28;
    const y = Math.random() < 0.5 ? (GROUND_Y - 120) : (GROUND_Y - 200);
    coins.push({ x: canvas.width/ (ctx.getTransform().a) + rand(0,40), y: y, w:size, h:size, type:'coin', taken:false });
  }

  // ===== Update =====
  let last = 0;
  function loop(t){
    const dtMs = Math.min(32, t - last || 16);
    const dt = dtMs / 16.6667; // normalize to 60 FPS units
    last = t;

    // world speed scales with score
    const speed = BASE_SPEED + Math.min(8, state.score * 0.00015);

    if (state.phase === 'playing'){
      state.time += dtMs;
      // Player physics
      player.vy += GRAVITY * dt;
      player.y  += player.vy * dt;
      if (player.y + player.h >= GROUND_Y){
        player.y = GROUND_Y - player.h;
        player.vy = 0;
        player.onGround = true;
      }
      // Scroll items
      obstacles.forEach(o=> o.x -= speed * dt * 10);
      coins.forEach(c=>     c.x -= speed * dt * 10);

      // Spawn timers
      spawnBombTimer -= dtMs;
      spawnCoinTimer -= dtMs;
      if (spawnBombTimer <= 0){
        spawnCone();
        spawnBombTimer = rand(900, 1500); // ms
      }
      if (spawnCoinTimer <= 0){
        spawnCoin();
        spawnCoinTimer = rand(600, 1200); // ms
      }

      // Collisions
      const hb = player.hitbox();
      for (const b of obstacles){
        if (aabb(hb, b)){ gameOver(); break; }
      }
      for (const c of coins){
        if (!c.taken && aabb(hb,c)){
          c.taken = true;
          state.score += COIN_GAIN;
        }
      }

      // Cleanup off-screen
      while (obstacles.length && obstacles[0].x + obstacles[0].w < -40) obstacles.shift();
      while (coins.length && coins[0].x + coins[0].w < -40) coins.shift();

      // Passive score (distance)
      state.score += 0.1 * dtMs/16.67;
    }

    // Draw
    render(speed);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function gameOver(){
    state.phase = 'gameover';
    if (state.score > state.best){
      state.best = Math.floor(state.score);
      localStorage.setItem('bike_best', state.best);
      document.getElementById('best').textContent = state.best;
    }
  }

  // ===== Render =====
  let roadOffset = 0;
  function render(speed){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Sky gradient
    const w = canvas.width/ctx.getTransform().a, h = canvas.height/ctx.getTransform().d;
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'#0f1420'); g.addColorStop(1,'#1a2230');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

    // Parallax buildings
    drawCityLayer(0.2, 70, '#1b2333');
    drawCityLayer(0.4, 120, '#141b29');

    // Road
    ctx.fillStyle = '#0b0d12';
    ctx.fillRect(0,GROUND_Y+10,w,h-GROUND_Y-10);

    // Lane dashes
    roadOffset += (speed*2);
    ctx.fillStyle = '#2c3445';
    const dashY = GROUND_Y + 36;
    for (let x = -((roadOffset)% (LANE_DASH_W*2)); x < w; x += LANE_DASH_W*2){
      ctx.fillRect(x, dashY, LANE_DASH_W, 6);
    }

    // Player
    drawPlayer();

    // Coins
    for (const c of coins) drawCoin(c);

    // Bombs
    for (const o of obstacles) drawCone(o);

    // UI overlays
    document.getElementById('score').textContent = Math.floor(state.score);

    if (state.phase !== 'playing'){
      ctx.save();
      ctx.textAlign='center';
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(w*0.5-220, h*0.5-70, 440, 140);
      ctx.strokeStyle = 'rgba(255,255,255,.15)';
      ctx.strokeRect(w*0.5-220, h*0.5-70, 440, 140);
      ctx.fillStyle = '#fff';
      ctx.font = '700 28px system-ui, sans-serif';
      const title = state.phase==='ready' ? 'Tap / Space to Start' : 'Game Over';
      ctx.fillText(title, w*0.5, h*0.5-10);
      ctx.font = '400 16px system-ui, sans-serif';
      const sub = state.phase==='ready' ? 'Avoid cones, collect coins' : 'Press R or Tap to restart';
      ctx.fillText(sub, w*0.5, h*0.5+22);
      ctx.restore();
    }
  }

  function drawPlayer(){
  const targetH = 140;
  let img, ready;

  if (!player.onGround && bikeJumpReady) {
    img = bikeJumpImg; // jumping image
    ready = bikeJumpReady;
  } else {
    img = bikeImg;
    ready = bikeReady;
  }

  if (ready){
    const scale = targetH / img.naturalHeight;
    const w = img.naturalWidth * scale;
    const h = targetH;
    player.w = w; player.h = h;
    ctx.drawImage(img, player.x, player.y, w, h);
  } else {
    ctx.fillStyle = '#6ee7ff';
    ctx.fillRect(player.x, player.y, player.w, player.h);
  }
}

  function drawCoin(c){
    if (c.taken) return;
    ctx.save();
    ctx.beginPath();
    ctx.arc(c.x + c.w/2, c.y + c.h/2, c.w/2, 0, Math.PI*2);
    ctx.fillStyle = '#ffd34d';
    ctx.fill();
    ctx.strokeStyle = '#d1a62b';
    ctx.lineWidth = 3; ctx.stroke();
    ctx.restore();
  }

  function drawCone(o){
  if (coneReady) {
    ctx.drawImage(coneImg, o.x, o.y, o.w, o.h);
  } else {
    // fallback placeholder
    ctx.fillStyle = '#ff6600';
    ctx.beginPath();
    ctx.moveTo(o.x + o.w/2, o.y); // top
    ctx.lineTo(o.x + o.w, o.y + o.h); // right
    ctx.lineTo(o.x, o.y + o.h); // left
    ctx.closePath();
    ctx.fill();
  }
}

  function drawCityLayer(speedFactor, baseH, color){
    const w = canvas.width/ctx.getTransform().a;
    const h = canvas.height/ctx.getTransform().d;
    const step = 60;
    const offset = ((state.time*0.04*speedFactor) % step);
    ctx.fillStyle = color;
    for (let x=-offset; x<w; x+=step){
      const bh = baseH + ((x*37) % 90);
      const bw = step - 6;
      ctx.fillRect(x, GROUND_Y - bh, bw, bh);
      // windows
      ctx.globalAlpha = 0.12;
      for (let wy=GROUND_Y - bh + 10; wy<GROUND_Y-10; wy+=14){
        for (let wx=x+8; wx<x+bw-8; wx+=16){
          ctx.fillRect(wx, wy, 8, 6);
        }
      }
      ctx.globalAlpha = 1;
    }
  }
})();
</script>
</body>
</html>



